# GC总结

## A) GC演进过程

		1. 引用计数: 通过对对象引用与对对象删除进行计数标记，但是当存在死循环，引用无法被释放的情况，计数算法会不释放内存，造成内存泄漏 -> 内存溢出
  		2. 标记清除: 通过对根对象进行标记清除，对可达对象Mark，对不可达对象做Sweep
  		3. 压缩: 对内存存储碎片进行碎片整理
  		4. 复制，移动: 对于GC前，Eden区与存活区的某一个小区里的存活对象通过复制的方式复制到年轻代的另一个存活区，对不可达的对象进行清除，当存活对象>=Max TenuringThreshold时，存活对象进入老年区

5. 对于GC root有以下几种类型：

   ​	a）局部变量和输入参数

   ​	b）正在执行的线程

   ​	c）所有类的静态字段

   ​	d）JNI引用

## B）各种GC的总结

 1. 串行GC

     	1. 年轻代：mark-copy
     	2. 老年代：mark-copy-compact
     	3. 优点：对几百MB，单核CPU处理比较快，支持小型单机场景
     	4. 缺点：无法并行处理，CPU利用率高，暂存时间长
     	5. 改进：利用-XX：+UseParNewGC，改进Serial GC，配合CMS使用

	2. 并行GC

    年轻代：mark-copy

    老年代：mark-sweep-compact

    优点：可并行进行垃圾回收，在GC期间，所有CPU内核并行清理垃圾，总暂停时间更短，GC的间隔期间不消耗任何系统资源，主要目的在于增加吞吐量

    缺点：延时较高，做GC时，业务无法执行

	3. CMS GC

    	1. 年轻代：mark-copy
    	2. 老年代：mark-sweep
    	3. 优点：不对老年代进行整理，使用free-list进行标记，在mark-sweep阶段对工作线程与GC线程并发执行，降低GC停顿导致的系统延迟
    	4. 缺点：CMS对老年代内存碎片造成不可预测的暂停时间
    	5. 对于Initial Mark和Final Remark涉及Stop the World态

	4. G1 GC:-XX +UseG1GC

    	1. 将STW停顿的时间和分布变成可预期和可配置的 
    	2. 优点：将存放对象的小块堆区域替代Young，Old区域，根据增量的方式处理一部分内存块，对垃圾最多的小块优先处理

